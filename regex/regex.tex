% Created 2020-05-22 vie 23:58
% Intended LaTeX compiler: pdflatex
\documentclass[presentation]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usetheme{default}
\author{guillermo}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={guillermo},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 26.3 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\begin{frame}{Outline}
\tableofcontents
\end{frame}

\begin{frame}[label={sec:orgefa8e4e}]{Expresiones regulares}
\begin{block}{Comandos de python}
\begin{block}{import re}
Libreria
\end{block}
\begin{block}{pattern = r"[Inserte patron]"}
\end{block}
\begin{block}{re.match(pattern, "string")}
Encuentra si el patron corresponde al principio de string sino, None
\end{block}
\begin{block}{re.search(pattern, "string")}
Encuentra si el patron existe en cualquier parte del string. Devuelve un objeto con varios metodos.
.group() : devuelve el patron
.start() : devuelve la posicion inicial
.end()   : devuelve la posicion final
.span()  : devuelve la tupla posicion inicial, final
\end{block}
\begin{block}{re.findall(pattern, "string")}
Devuelve una lista con todas las subcadenas que coinciden con el patron
\end{block}
\begin{block}{re.sub(pattern, replace, string, count = 0)}
Reemplaza todas las ocurrencias de "pattern" por "replace" en el string, "count" veces
\end{block}

\begin{block}{re.compile(pattern)}
Compila el patron
	result = re.match(pattern, string)
Es similar a
	obj = re.compile(pattern)
	result = obj.match(string)
\end{block}
\end{block}
\begin{block}{Metacaracteres}
Para escapar los metacaracteres, se coloca $\backslash$ delante, sin embargo esto puede causar problemas. Por ej \verb|\n| es un caracter.
Para evitar esto se puede usar tres o cuatro barras, o usar cadenas puras, con una r delante de la cadena, ej r"algo", si este "algo" contiene \verb|\n|, lo considerará como dos caracteres, $\backslash$ y n
\begin{block}{Caracteres de posicion}
\begin{itemize}
\item .     empareja cualquier caracter, excepto una nueva linea
\item \^{}     establece el inicio de cadena o una linea de cadena en modo multiline
\item \$     establece el final de cadena o una linea cadena en modo multiline
\end{itemize}
\end{block}

\begin{block}{Clases de caracter}
\begin{itemize}
\item\relax [abc]    clase de caracter que coincide 1 caracter de los especificados en el corchete
\begin{enumerate}
\item\relax [abc][def] coincidirá "ad"
\item\relax [a-z]      coincidirá 1 caracter de la a a la z
\item\relax [G-P]      coincidirá 1 caracter de la G a la P
\item\relax [0-9]      coincidirá 1 caracter de 0 a 9
\item\relax [A-Za-z]   coincidira 1 caracter con cualquier letra
\end{enumerate}

\item\relax [\^{}]   invierte la clase de caracter, i.e, coincide caracteres excepto los especificados por el corchete
\end{itemize}
\end{block}

\begin{block}{Caracteres de repeticion}
\begin{itemize}
\item *     el caracter anterior existe 0 o mas veces
\item +     el caracter anterior existe 1 o mas veces
\item ?     el caracter anterior existe 0 o 1 ves
\item \{m,n\} el caracter anterior existe entre m y n veces, si falta el primer numero se asume 0, si falta el segundo se asume infinito
\end{itemize}
\end{block}

\begin{block}{Grupos}
()    grupo se crea con parentesis, se puede usar con metacarácteres
Al usar el objeto re.match:
\begin{itemize}
\item el metodo .group() devuelve toda la coincidencia
\item el metodo .group(n), con n>1, devuelve la coincidencia n, de izq a derecha
\item el metodo .groups() devuelve todos los grupos a partir del primero
\end{itemize}

Metacarácter de grupo
\begin{itemize}
\item | empareja uno de los dos caracteres, (a|b) emparejara "a" o "b"
\end{itemize}

Se puede especificar grupos
\begin{itemize}
\item (?P<nombre>contenido) son grupos con nombres, pueden ser accedidos con .group("nombre")
\item (?:contenido) son grupos sin nombre, no serán accedidos por .groups()
\item AA(?!BB), coincide AA sólo si el siguiente string no es BB
\item (?<!BB)AA, coincide AA sólo si el string anterior no es BB
\end{itemize}
\end{block}

\begin{block}{Secuencias especiales}
\begin{itemize}
\item Referencias a la coincidencia de un grupo, que ya se emparejó
Ej: r"(.+)(.+)(.+)$\backslash$1"
	repetirá la coincidencia del primer (.+)
	si usamos "abc bca cab abc", hará match. Otros ejemplos:
\begin{itemize}
\item (.+)(.+)(.+)$\backslash$1 hará match con "abc bca cab abc"
\item (.+)(.+)(.+)$\backslash$2 hará match con "abc bca cab bca"
\item (.+)(.+)(.+)$\backslash$3 hará match con "abc bca cab cab"
\end{itemize}
\item \verb{\d} digitos, equivalente a [0-9]
\item \verb|\s| espacios en blanco, equivalente a \verb|[\t\n\r\f\v]|
\item \verb|\w| caracteres alfanumericos, equivalente a [a-zA-Z0-9\_]
Sus versiones en mayuscula significan lo contrario

\item \verb|\A \Z|, especifican principio y final de toda la cadena, ignorando saltos de linea
\item \verb|\b| (boundary) caracter no-alfanumerico justo despues de alguna letra y justo antes de la expresion a interés
\item \verb|\B| (boundary) caracter alfanumerico, opuesto  \verb|\b|
\end{itemize}
\end{block}
\end{block}
\end{frame}
\end{document}
